
- 1. Вывести топ-3 аптеки; 

     Описание решенной задачи:

     Запрос определяет топ-3 аптеки с наибольшим объемом продаж. 

     Объем продаж считается как сумма произведений цены и количества купленных позиций для каждой аптеки. 

     Итоговый результат — три аптеки-лидера по общему объему продаж.

- Используемые функции (Используемые функции и конструкции:

- SUM() — агрегирующая функция для подсчета общего объема продаж

- GROUP BY — группировка по названию аптеки

- ORDER BY — сортировка по объему продаж в порядке убывания

- LIMIT — ограничение результата тремя строками);



-- SQL код для вывода топ-3 аптек по объему продаж
-- Объем продаж = price * count

SELECT
    pharmacy_name,                -- название аптеки
    SUM(price * count) AS total_sales  -- общий объем продаж
FROM
    pharma_orders
GROUP BY
    pharmacy_name                 -- группировка по названию аптеки
ORDER BY
    total_sales DESC              -- сортировка по убыванию объема продаж
LIMIT 3;                         -- вывод только трех лидеров


- Итоговое решение задачи с бизнесовым ответом:
  В результате выполнения запроса определяются три аптеки с наибольшим общим объемом продаж. 
  Это позволяет выявить ключевых лидеров рынка среди аптек по объему реализованных товаров.


- 2 Вывести топ-3 лекарства
    Описание решенной задачи:
    Запрос выводит топ-3 лекарства с наибольшим объемом продаж. 
	Объем продаж рассчитывается как сумма произведений цены на количество проданных единиц для каждого лекарства. 
	Результат показывает три самых продаваемых препарата по общему объему продаж.
- Используемые функции (
- SUM() — агрегирующая функция для подсчета общего объема продаж

- GROUP BY — группировка по названию лекарства

- ORDER BY — сортировка по объему продаж в порядке убывания

- LIMIT — ограничение результата тремя строками);
 
-- SQL код для вывода топ-3 лекарств по объему продаж
-- Объем продаж = price * count

SELECT
    drug,                          -- название лекарства
    SUM(price * count) AS total_sales  -- общий объем продаж по лекарству
FROM
    pharma_orders
GROUP BY
    drug                           -- группировка по названию лекарства
ORDER BY
    total_sales DESC               -- сортировка по убыванию объема продаж
LIMIT 3;                          -- вывод только трех лидеров

- Итоговое решение задачи с бизнесовым ответом:
   В результате запроса выявляются три лекарства с наибольшим объемом продаж, что позволяет 
   определить наиболее востребованные препараты на рынке и оптимизировать ассортимент и закупки.

3 Фильтрация агрегированных значений
- Описание решенной задачи:
  Задача заключается в фильтрации аптек по общему обороту (сумме продаж). 
  Нужно вывести только те аптеки, у которых суммарный оборот (выручка) превышает 1.8 миллиона.
  Оборот рассчитывается как сумма произведений цены на количество проданных товаров.

Используемые функции и конструкции:

- SUM() — агрегирующая функция для подсчета общего оборота

- GROUP BY — группировка по названию аптеки

- HAVING — фильтрация агрегированных значений (по сумме оборота)

- ORDER BY — сортировка по убыванию оборота (для удобства просмотра)

-- SQL код для вывода аптек с оборотом от 1.8 миллионов

SELECT
    pharmacy_name,                   -- название аптеки
    SUM(price * count) AS total_turnover  -- общий оборот аптеки
FROM
    pharma_orders
GROUP BY
    pharmacy_name                    -- группировка по аптеке
HAVING
    SUM(price * count) >= 1800000   -- фильтрация аптек с оборотом >= 1.8 млн
ORDER BY
    total_turnover DESC;             -- сортировка по убыванию оборота

- Итоговое решение задачи с бизнесовым ответом:
  Данный запрос позволяет выявить аптеки с высокими оборотами, превышающими 1.8 миллиона, 
  что помогает сосредоточить внимание на ключевых игроках рынка и оценить их вклад в общие продажи.
  
4 Оконная функция для расчета накопленного значения. 
  - Описание решенной задачи:
    Задача состоит в вычислении накопленной (кумулятивной) суммы продаж по каждой аптеке с учетом даты заказа.
	Для каждой аптеки и даты заказа нужно посчитать сумму всех продаж (price * count) 
	начиная с самой ранней даты до текущей строки. 
	Это позволяет анализировать динамику продаж во времени.

- Используемые функции и конструкции:

   Оконная функция SUM() OVER (PARTITION BY ... ORDER BY ...) — для вычисления накопленной суммы

   PARTITION BY — разделение данных по каждой аптеке

   ORDER BY — упорядочивание по дате заказа внутри каждой аптеки
   
   -- SQL код для вычисления накопленной суммы продаж по каждой аптеке с разбивкой по дате заказа

SELECT
    pharmacy_name,                          -- название аптеки
    report_date,                            -- дата заказа
    SUM(price * count) OVER (
        PARTITION BY pharmacy_name          -- разделение по аптеке
        ORDER BY report_date                 -- упорядочивание по дате заказа
        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW  -- накопление от начала до текущей строки
    ) AS cumulative_sales                   -- накопленная сумма продаж
FROM
    pharma_orders
ORDER BY
    pharmacy_name,
    report_date;

- Итоговое решение задачи с бизнесовым ответом:
  Данный запрос позволяет отследить динамику накопленных продаж по каждой аптеке с течением времени. 
  Это полезно для анализа трендов, оценки эффективности работы аптек и планирования дальнейших бизнес-решений.
  
5 Количество клиентов в аптеках.
- Описание решенной задачи:
  Задача — подсчитать количество уникальных клиентов, совершивших заказы в каждой аптеке.
  Для этого необходимо соединить таблицу заказов pharma_orders с таблицей клиентов customers
  по полю customer_id.
  Результат сортируется по убыванию количества клиентов, что позволяет определить аптеки с 
  наибольшей клиентской базой.

- Используемые функции и конструкции:

JOIN — для соединения таблиц по customer_id

COUNT(DISTINCT ...) — подсчет уникальных клиентов

GROUP BY — группировка по аптеке

ORDER BY — сортировка по количеству клиентов в порядке убывания

-- SQL код для подсчета количества уникальных клиентов в каждой аптеке

SELECT
    po.pharmacy_name,                     -- название аптеки из таблицы заказов
    COUNT(DISTINCT po.customer_id) AS unique_customers  -- количество уникальных клиентов
FROM
    pharma_orders po
JOIN
    customers c ON po.customer_id = c.customer_id  -- соединение с таблицей клиентов по customer_id
GROUP BY
    po.pharmacy_name                      -- группировка по аптеке
ORDER BY
    unique_customers DESC;                -- сортировка по убыванию количества клиентов

- Итоговое решение задачи с бизнесовым ответом:
  Данный запрос позволяет выявить аптеки с наибольшим числом уникальных клиентов,  
  что является важным показателем популярности и охвата рынка.
  Это помогает бизнесу ориентироваться на ключевые точки продаж и строить маркетинговые стратегии.
  
6 Лучшие клиенты. Соединяем таблицы клиентов и заказов.
  - Описание решенной задачи:
     Задача — определить топ-10 лучших клиентов по общей сумме заказов.
	 Для этого необходимо соединить таблицы customers и pharma_orders по полю customer_id, 
	 подсчитать суммарный объем покупок каждого клиента (цена * количество), 
	 а затем отсортировать клиентов по убыванию этой суммы.
	 В итоговом выводе отображаются имя, фамилия и отчество клиента.

Используемые функции и конструкции:

JOIN — для соединения таблиц по customer_id

SUM(price * count) — подсчет общей суммы заказов

GROUP BY — группировка по клиенту (имя, фамилия, отчество)

ORDER BY — сортировка по сумме заказов в порядке убывания

LIMIT — ограничение результата топ-10 клиентов

Код с комментариями:

-- SQL код для вывода топ-10 клиентов по общей сумме заказов

SELECT
    c.first_name,                           -- имя клиента
    c.last_name,                            -- фамилия клиента
    c.second_name,                         -- отчество клиента
    SUM(po.price * po.count) AS total_spent  -- общая сумма заказов клиента
FROM
    customers c
JOIN
    pharma_orders po ON c.customer_id = po.customer_id  -- соединение таблиц по customer_id
GROUP BY
    c.customer_id, c.first_name, c.last_name, c.second_name  -- группировка по клиенту
ORDER BY
    total_spent DESC                       -- сортировка по убыванию суммы заказов
LIMIT 10;                                 -- вывод топ-10 клиентов

- Итоговое решение задачи с бизнесовым ответом:
  Запрос позволяет выявить 10 лучших клиентов по объему покупок, что помогает сосредоточить
  маркетинговые усилия на наиболее ценных клиентах и развивать программы лояльности.
  
7 Накопленная сумма по клиентам. 
  - Описание решенной задачи:
    Задача — посчитать накопленную (кумулятивную) сумму заказов для каждого клиента по датам заказов.
	Для этого соединяем таблицы клиентов и заказов, объединяем имя, фамилию и отчество в одно поле ФИО,
	а затем с помощью оконной функции вычисляем накопленную сумму (цена * количество) 
	по датам заказов для каждого клиента.

- Используемые функции и конструкции:

JOIN — соединение таблиц по customer_id

Конкатенация строк с помощью CONCAT_WS — объединение ФИО в одно поле

Оконная функция SUM() OVER (PARTITION BY ... ORDER BY ...) — вычисление накопленной суммы

PARTITION BY — разделение по клиенту

ORDER BY — упорядочивание по дате заказа

- Код с комментариями:

-- SQL код для вычисления накопленной суммы заказов по каждому клиенту с объединением ФИО

SELECT
    c.customer_id,                                         -- идентификатор клиента
    CONCAT_WS(' ', c.last_name, c.first_name, c.second_name) AS full_name,  -- объединение ФИО в одно поле
    po.report_date,                                        -- дата заказа
    SUM(po.price * po.count) OVER (
        PARTITION BY c.customer_id                         -- разделение по клиенту
        ORDER BY po.report_date                            -- упорядочивание по дате заказа
        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW  -- накопление от начала до текущей строки
    ) AS cumulative_spent                                  -- накопленная сумма заказов
FROM
    customers c
JOIN
    pharma_orders po ON c.customer_id = po.customer_id    -- соединение таблиц по customer_id
ORDER BY
    c.customer_id,
    po.report_date;

- Итоговое решение задачи с бизнесовым ответом:
  Запрос позволяет отследить динамику накопленных расходов каждого клиента по датам заказов.
  Это помогает анализировать покупательскую активность и поведение клиентов во времени, 
  а также строить персонализированные маркетинговые стратегии.
  
8 Самые частые клиенты аптек Горздрав и Здравсити
- Описание решенной задачи:
  Задача — определить топ-10 самых частых клиентов для двух аптек: "Горздрав" и "Здравсити". 
  Для каждой аптеки создаются временные таблицы с подсчетом количества заказов каждого клиента, 
  затем выбираются топ-10 клиентов по количеству заказов. Итоговые данные объединяются 
  с помощью оператора UNION.

- Используемые функции и конструкции:

WITH — создание временных (CTE) таблиц

JOIN — соединение таблиц заказов и клиентов по customer_id

COUNT() — подсчет количества заказов клиента

GROUP BY — группировка по клиенту

ORDER BY — сортировка по количеству заказов

LIMIT — ограничение топ-10 клиентов

UNION — объединение результатов двух запросов

- Код с комментариями:

sql
-- SQL код для определения топ-10 самых частых клиентов аптек "Горздрав" и "Здравсити"

WITH gorzdrav_top_clients AS (
    SELECT
        c.customer_id,
        CONCAT_WS(' ', c.last_name, c.first_name, c.second_name) AS full_name,  -- объединение ФИО
        COUNT(po.order_id) AS orders_count                                      -- количество заказов
    FROM
        pharma_orders po
    JOIN
        customers c ON po.customer_id = c.customer_id
    WHERE
        po.pharmacy_name = 'Горздрав'                                          -- фильтр по аптеке "Горздрав"
    GROUP BY
        c.customer_id, c.last_name, c.first_name, c.second_name
    ORDER BY
        orders_count DESC                                                      -- сортировка по убыванию количества заказов
    LIMIT 10                                                                  -- топ-10 клиентов
),

zdravcity_top_clients AS (
    SELECT
        c.customer_id,
        CONCAT_WS(' ', c.last_name, c.first_name, c.second_name) AS full_name,  -- объединение ФИО
        COUNT(po.order_id) AS orders_count                                      -- количество заказов
    FROM
        pharma_orders po
    JOIN
        customers c ON po.customer_id = c.customer_id
    WHERE
        po.pharmacy_name = 'Здравсити'                                        -- фильтр по аптеке "Здравсити"
    GROUP BY
        c.customer_id, c.last_name, c.first_name, c.second_name
    ORDER BY
        orders_count DESC                                                      -- сортировка по убыванию количества заказов
    LIMIT 10                                                                  -- топ-10 клиентов
)

-- Объединяем результаты двух аптек
SELECT
    'Горздрав' AS pharmacy_name,
    customer_id,
    full_name,
    orders_count
FROM
    gorzdrav_top_clients

UNION ALL

SELECT
    'Здравсити' AS pharmacy_name,
    customer_id,
    full_name,
    orders_count
FROM
    zdravcity_top_clients;
	
	
- Итоговое решение задачи с бизнесовым ответом:
  Данный запрос позволяет выявить самых активных клиентов для аптек "Горздрав" и "Здравсити". 
  Это помогает сфокусировать маркетинговые и клиентские программы на наиболее лояльных
  покупателях каждой аптеки, улучшая удержание клиентов и повышая продажи.

## Вторая часть задач:

1.1 Сравнение динамики продаж между Москвой и Санкт-Петербургом.
- Описание решенной задачи:
  Задача — сравнить динамику продаж лекарств по аптекам в двух городах: Москве и Санкт-Петербурге. 
  Для каждого месяца подсчитываем общий объем продаж (сумма price * count) по аптекам 
  в Москве и отдельно в Санкт-Петербурге. Затем объединяем результаты по месяцам и вычисляем 
  процентное изменение продаж между двумя городами.

- Используемые функции и конструкции:

DATE_TRUNC('month', report_date) — группировка по месяцам

SUM(price * count) — подсчет объема продаж

GROUP BY — группировка по городу, аптеке и месяцу

JOIN — объединение результатов по месяцам

Вычисление процентной разницы

COALESCE — обработка возможных NULL при отсутствии данных

- Код с комментариями:

WITH sales_moscow AS (
    SELECT
        pharmacy_name,
        DATE_TRUNC('month', report_date::timestamp) AS month,  -- Приведение к timestamp
        SUM(price * count) AS total_sales_moscow
    FROM
        pharma_orders
    WHERE
        city = 'Москва'
    GROUP BY
        pharmacy_name,
        month
),

sales_spb AS (
    SELECT
        pharmacy_name,
        DATE_TRUNC('month', report_date::timestamp) AS month,  -- Приведение к timestamp
        SUM(price * count) AS total_sales_spb
    FROM
        pharma_orders
    WHERE
        city = 'Санкт-Петербург'
    GROUP BY
        pharmacy_name,
        month
)

SELECT
    COALESCE(m.pharmacy_name, s.pharmacy_name) AS pharmacy_name,
    COALESCE(m.month, s.month) AS month,
    COALESCE(total_sales_moscow, 0) AS sales_moscow,
    COALESCE(total_sales_spb, 0) AS sales_spb,
    CASE 
        WHEN COALESCE(total_sales_spb, 0) = 0 THEN NULL
        ELSE ROUND(((COALESCE(total_sales_moscow, 0) - total_sales_spb) / total_sales_spb) * 100, 2)
    END AS percent_difference
FROM
    sales_moscow m
FULL OUTER JOIN
    sales_spb s
ON
    m.pharmacy_name = s.pharmacy_name AND m.month = s.month
ORDER BY
    pharmacy_name,
    month;

- Краткие выводы:

   В некоторых аптеках и месяцах продажи в Москве значительно выше, чем в Санкт-Петербурге, 
   что отражается в положительном процентном различии.

   В ряде случаев продажи в Санкт-Петербурге превышают московские, процентное различие отрицательное.

   Наличие NULL в процентной разнице указывает на отсутствие продаж в одном из городов за соответствующий месяц.

   Такой анализ помогает выявить сезонные и региональные особенности спроса,  
   что важно для планирования закупок и маркетинговых кампаний.
   
1.2 Лекарства от насморка. 
- Описание решенной задачи:
  Задача — выделить лекарства, названия которых начинаются со слова "аква" (независимо от регистра), 
  подсчитать общий объем продаж для каждого такого препарата, отсортировать их по убыванию
  объема продаж и вычислить долю каждого лекарства в общем объеме продаж всех выбранных препаратов.

- Используемые функции и конструкции:

LOWER() — приведение строк к нижнему регистру

LIKE — фильтрация по шаблону (начинается с "аква")

SUM(price * count) — подсчет общего объема продаж

GROUP BY — группировка по названию препарата

Оконная функция SUM() OVER() — подсчет общего объема продаж по всем выбранным препаратам для вычисления доли

ROUND() — округление результата

Приведение report_date к типу timestamp (если нужно, для других задач)

Код с комментариями:

-- SQL код для анализа продаж лекарств, начинающихся с "аква"

WITH filtered_drugs AS (
    SELECT
        LOWER(drug) AS drug_lower,                   -- приводим название лекарства к нижнему регистру
        price,
        count,
        report_date::timestamp AS report_date_ts    -- преобразуем report_date к типу timestamp (если потребуется в дальнейшем)
    FROM
        pharma_orders
    WHERE
        LOWER(drug) LIKE 'аква%'                      -- фильтрация по названию, начинающемуся на "аква"
)

SELECT
    drug_lower AS drug_name,                          -- название лекарства в нижнем регистре
    SUM(price * count) AS total_sales,                -- общий объем продаж по препарату
    ROUND(SUM(price * count) * 100.0 / SUM(SUM(price * count)) OVER (), 2) AS sales_share_percent  -- доля в общем объеме продаж
FROM
    filtered_drugs
GROUP BY
    drug_lower
ORDER BY
    total_sales DESC;                                 -- сортировка по убыванию объема продаж

- Итоговое решение задачи с бизнесовым ответом:
  В результате запроса выявлены препараты, начинающиеся на "аква", с подсчитанным объемом продаж и 
  долей каждого препарата в общем объеме продаж данной группы. Это позволяет понять, какие лекарства
  от насморка наиболее популярны и какую часть рынка они занимают, что важно для планирования
  ассортимента и маркетинга.
  
1.3 Кто наши клиенты.
- Описание решенной задачи:
  Задача — определить возрастные и гендерные группы клиентов, вычислить возраст каждого клиента
  на основе даты рождения, распределить клиентов по категориям с помощью оператора CASE WHEN, 
  а затем подсчитать долю продаж, приходящуюся на каждую группу.

- Используемые функции и конструкции:

AGE() — вычисление возраста клиента на основе даты рождения и текущей даты

EXTRACT(YEAR FROM AGE(...)) — получение количества полных лет

CASE WHEN — классификация клиентов по возрастным и гендерным группам

JOIN — соединение таблиц клиентов и заказов по customer_id

SUM(price * count) — подсчет объема продаж по группам

Оконная функция SUM() OVER() — вычисление общего объема продаж для расчета доли

Приведение report_date к типу timestamp (если нужно для других задач)

- Код с комментариями:

-- SQL код для анализа клиентов по возрастным и гендерным группам с подсчетом доли продаж

WITH customer_sales AS (
    SELECT
        c.customer_id,
        c.gender,
        EXTRACT(YEAR FROM AGE(CURRENT_DATE, c.date_of_birth::date)) AS age,  -- приведение к date
        po.price,
        po.count,
        po.report_date::timestamp AS report_date_ts
    FROM
        customers c
    JOIN
        pharma_orders po ON c.customer_id = po.customer_id
),

grouped_sales AS (
    SELECT
        CASE
            WHEN gender = 'М' AND age < 30 THEN 'Мужчины младше 30'
            WHEN gender = 'М' AND age BETWEEN 30 AND 45 THEN 'Мужчины 30-45'
            WHEN gender = 'М' AND age > 45 THEN 'Мужчины старше 45'
            WHEN gender = 'Ж' AND age < 30 THEN 'Женщины младше 30'
            WHEN gender = 'Ж' AND age BETWEEN 30 AND 45 THEN 'Женщины 30-45'
            WHEN gender = 'Ж' AND age > 45 THEN 'Женщины старше 45'
            ELSE 'Прочие'
        END AS customer_group,
        SUM(price * count) AS total_sales
    FROM
        customer_sales
    GROUP BY
        customer_group
)

SELECT
    customer_group,
    total_sales,
    ROUND(total_sales * 100.0 / SUM(total_sales) OVER (), 2) AS sales_share_percent  -- доля продаж по группе в процентах
FROM
    grouped_sales
ORDER BY
    total_sales DESC;

- Итоговое решение задачи с бизнесовым ответом:

- Запрос позволяет сегментировать клиентов по возрасту и полу, а также определить, 
  какая доля продаж приходится на каждую группу. Это помогает лучше понять целевую аудиторию,
  оптимизировать маркетинговые кампании и ассортимент товаров для разных сегментов клиентов.
  
##  Вторая часть задач

2.1 Запрос "Топ-3 аптеки"
- Описание решенной задачи:
  Запрос определяет топ-3 аптеки по объему продаж. 
  Объем продаж считается как сумма произведений цены и количества купленных позиций для каждой аптеки.
  Итоговый результат — три аптеки-лидера по общему объему продаж.

- Используемые функции и конструкции:

SUM(price * count) — подсчет общего объема продаж

GROUP BY — группировка по названию аптеки

ORDER BY — сортировка по объему продаж в порядке убывания

LIMIT — ограничение результата тремя строками

Преобразование report_date в тип timestamp (на случай, если потребуется для других задач)

- Код с комментариями:

- Итоговое решение задачи с бизнесовым ответом:
  В результате выполнения запроса определяются три аптеки с наибольшим общим объемом продаж. 
  Это позволяет выявить ключевых лидеров рынка среди аптек по объему реализованных товаров 
  и принять решения по развитию партнерских отношений с наиболее успешными точками.
  
2.2 Запрос "Топ-3 лекарства"
- Описание решенной задачи:
  Запрос выводит топ-3 лекарства по объему продаж. 
  Объем продаж рассчитывается как сумма произведений цены на количество проданных единиц для каждого лекарства.
  Итоговый результат показывает три самых продаваемых препарата по общему объему продаж.

- Используемые функции и конструкции:

SUM(price * count) — подсчет общего объема продаж

GROUP BY — группировка по названию лекарства

ORDER BY — сортировка по объему продаж в порядке убывания

LIMIT — ограничение результата тремя строками

Преобразование report_date в тип timestamp (если потребуется для других задач)

- Код с комментариями:

-- SQL код для вывода топ-3 лекарств по объему продаж
-- Объем продаж = price * count

SELECT
    drug,                                          -- название лекарства
    SUM(price * count) AS total_sales              -- общий объем продаж по лекарству
FROM
    pharma_orders
-- report_date преобразуем в timestamp, если потребуется для других задач:
-- , report_date::timestamp AS report_date_ts
GROUP BY
    drug                                           -- группировка по названию лекарства
ORDER BY
    total_sales DESC                               -- сортировка по убыванию объема продаж
LIMIT 3;                                          -- вывод только трех лидеров

- Итоговое решение задачи с бизнесовым ответом:
  В результате запроса выявляются три лекарства с наибольшим объемом продаж,
  что позволяет определить наиболее востребованные препараты на рынке и 
  оптимизировать ассортимент и закупки.
  
2.3 Запрос "Аптеки от 1.8 млн оборота
- Описание решенной задачи:
  Задача — вывести аптеки, у которых общий объем продаж (оборот) превышает 1.8 миллиона.
  Оборот рассчитывается как сумма произведений цены на количество проданных товаров. 
  Для фильтрации по сумме оборота используется конструкция HAVING.

- Используемые функции и конструкции:

SUM(price * count) — подсчет общего оборота аптеки

GROUP BY — группировка по названию аптеки

HAVING — фильтрация по агрегированному значению (обороту)

Преобразование report_date в тип timestamp (если потребуется для других задач)

- Код с комментариями:

-- SQL код для вывода аптек с оборотом более 1.8 миллиона

SELECT
    pharmacy_name,                                  -- название аптеки
    SUM(price * count) AS total_turnover            -- общий оборот аптеки
FROM
    pharma_orders
-- report_date преобразуем в timestamp, если потребуется для других задач:
-- , report_date::timestamp AS report_date_ts
GROUP BY
    pharmacy_name                                   -- группировка по аптеке
HAVING
    SUM(price * count) >= 1800000                   -- фильтр по обороту >= 1.8 млн
ORDER BY
    total_turnover DESC;                            -- сортировка по убыванию оборота

- Итоговое решение задачи с бизнесовым ответом:
  Запрос позволяет выявить аптеки с оборотом более 1.8 миллиона, что помогает сосредоточить внимание
  на ключевых игроках рынка и оценить их вклад в общие продажи. 
  Это важно для принятия стратегических решений и оптимизации работы с крупными партнерами.
  
2.4 Запрос Накопленная сумма продаж по каждой аптеке (OVER)
- Описание решенной задачи:
  Задача — вычислить накопленную (кумулятивную) сумму продаж по каждой аптеке с учетом даты заказа. 
  Для каждой аптеки и даты заказа нужно посчитать сумму всех продаж (price * count) 
  начиная с самой ранней даты до текущей строки. Это позволяет анализировать динамику продаж во времени.

- Используемые функции и конструкции:

Оконная функция SUM() OVER (PARTITION BY ... ORDER BY ...) — для вычисления накопленной суммы

PARTITION BY — разделение данных по каждой аптеке

ORDER BY — упорядочивание по дате заказа внутри каждой аптеки

Преобразование report_date в тип timestamp внутри запроса

- Код с комментариями:

-- SQL код для вычисления накопленной суммы продаж по каждой аптеке с разбивкой по дате заказа

SELECT
    pharmacy_name,                          -- название аптеки
    report_date::timestamp AS report_date_ts,  -- преобразуем report_date в timestamp
    SUM(price * count) OVER (
        PARTITION BY pharmacy_name          -- разделение по аптеке
        ORDER BY report_date::timestamp     -- упорядочивание по дате заказа
        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW  -- накопление от начала до текущей строки
    ) AS cumulative_sales                   -- накопленная сумма продаж
FROM
    pharma_orders
ORDER BY
    pharmacy_name,
    report_date_ts;

- Итоговое решение задачи с бизнесовым ответом:
  Данный запрос позволяет отследить динамику накопленных продаж по каждой аптеке с течением времени. 
  Это полезно для анализа трендов, оценки эффективности работы аптек и планирования дальнейших бизнес-решений.
  
2.5 Запрос Количество клиентов в аптеках
- Описание решенной задачи:
  Задача — подсчитать количество уникальных клиентов для каждой аптеки. 
  Для этого необходимо соединить таблицы заказов и клиентов по customer_id, посчитать уникальных клиентов 
  на каждую аптеку и отсортировать аптеки по убыванию количества клиентов.

- Используемые функции и конструкции:

JOIN — соединение таблиц заказов и клиентов по customer_id

COUNT(DISTINCT ...) — подсчет уникальных клиентов

GROUP BY — группировка по названию аптеки

ORDER BY — сортировка по количеству клиентов в порядке убывания

Преобразование report_date в тип timestamp (если потребуется для других задач)

- Код с комментариями:


-- SQL код для подсчета количества уникальных клиентов в каждой аптеке

SELECT
    po.pharmacy_name,                          -- название аптеки из таблицы заказов
    COUNT(DISTINCT po.customer_id) AS unique_customers  -- количество уникальных клиентов
FROM
    pharma_orders po
JOIN
    customers c ON po.customer_id = c.customer_id       -- соединение с таблицей клиентов по customer_id
-- report_date преобразуем в timestamp, если потребуется для других задач:
-- , po.report_date::timestamp AS report_date_ts
GROUP BY
    po.pharmacy_name                             -- группировка по аптеке
ORDER BY
    unique_customers DESC;                        -- сортировка по убыванию количества клиентов

- Итоговое решение задачи с бизнесовым ответом:
  Данный запрос позволяет выявить аптеки с наибольшим количеством уникальных клиентов, 
  что является важным показателем популярности и охвата рынка. Это помогает бизнесу ориентироваться 
  на ключевые точки продаж и строить маркетинговые стратегии.
  
2.6 Запрос "Лучшие клиенты"
- Описание решенной задачи:
  Задача — определить топ-10 лучших клиентов по общей сумме заказов.
  Для этого необходимо соединить таблицы заказов и клиентов по customer_id, 
  подсчитать суммарный объем покупок каждого клиента (цена * количество), 
  проранжировать клиентов по убыванию суммы заказов с помощью оконной функции ROW_NUMBER(),
  и вывести только первые 10 клиентов.

- Используемые функции и конструкции:

JOIN — соединение таблиц заказов и клиентов по customer_id

SUM(price * count) — подсчет общей суммы заказов

GROUP BY — группировка по клиенту (имя, фамилия, отчество)

Оконная функция ROW_NUMBER() OVER (ORDER BY ...) — ранжирование клиентов

LIMIT или фильтрация по рангу — ограничение результата топ-10

Преобразование report_date в тип timestamp (если потребуется для других задач)

- Код с комментариями:

-- SQL код для вывода топ-10 клиентов по общей сумме заказов

WITH client_totals AS (
    SELECT
        c.customer_id,
        c.first_name,
        c.last_name,
        c.second_name,
        SUM(po.price * po.count) AS total_spent
    FROM
        customers c
    JOIN
        pharma_orders po ON c.customer_id = po.customer_id
    -- report_date преобразуем в timestamp, если потребуется для других задач:
    -- , po.report_date::timestamp AS report_date_ts
    GROUP BY
        c.customer_id, c.first_name, c.last_name, c.second_name
),

ranked_clients AS (
    SELECT
        customer_id,
        first_name,
        last_name,
        second_name,
        total_spent,
        ROW_NUMBER() OVER (ORDER BY total_spent DESC) AS rank
    FROM
        client_totals
)

SELECT
    first_name,
    last_name,
    second_name,
    total_spent
FROM
    ranked_clients
WHERE
    rank <= 10
ORDER BY
    total_spent DESC;

- Итоговое решение задачи с бизнесовым ответом:
  Запрос позволяет выявить 10 лучших клиентов по объему покупок, что помогает сосредоточить 
  маркетинговые усилия на наиболее ценных клиентах и развивать программы лояльности.
  
2.7 Запрос Накопленная сумма по клиентам
- Описание решенной задачи:
  Задача — вычислить накопленную (кумулятивную) сумму заказов по каждому клиенту с объединением ФИО в одно поле. 
  Для этого соединяем таблицы заказов и клиентов по customer_id, объединяем имя, 
  фамилию и отчество в одно поле, а затем с помощью оконной функции считаем накопленную сумму 
  (price * count) по дате заказа для каждого клиента.

- Используемые функции и конструкции:

JOIN — соединение таблиц заказов и клиентов по customer_id

CONCAT_WS(' ', last_name, first_name, second_name) — объединение ФИО в одно поле

Оконная функция SUM() OVER (PARTITION BY ... ORDER BY ...) — вычисление накопленной суммы

PARTITION BY — разделение по клиенту

ORDER BY — упорядочивание по дате заказа

Преобразование report_date в тип timestamp внутри запроса

- Код с комментариями:

-- SQL код для вычисления накопленной суммы заказов по каждому клиенту с объединением ФИО

SELECT
    c.customer_id,
    CONCAT_WS(' ', c.last_name, c.first_name, c.second_name) AS full_name,  -- объединение ФИО в одно поле
    po.report_date::timestamp AS report_date_ts,                           -- преобразование report_date в timestamp
    SUM(po.price * po.count) OVER (
        PARTITION BY c.customer_id                                         -- разделение по клиенту
        ORDER BY po.report_date::timestamp                                 -- упорядочивание по дате заказа
        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW                   -- накопление от начала до текущей строки
    ) AS cumulative_spent                                                  -- накопленная сумма заказов
FROM
    customers c
JOIN
    pharma_orders po ON c.customer_id = po.customer_id
ORDER BY
    c.customer_id,
    report_date_ts;

- Итоговое решение задачи с бизнесовым ответом:
  Запрос позволяет отследить динамику накопленных расходов каждого клиента по датам заказов. 
  Это помогает анализировать покупательскую активность и поведение клиентов во времени,
  а также строить персонализированные маркетинговые стратегии.
  
2.8 Запрос Самые частые клиенты аптек Горздрав и Здравсити
- Описание решенной задачи:
  Задача — определить топ-10 самых частых клиентов для двух аптек: "Горздрав" и "Здравсити".
  Для каждой аптеки создаются временные таблицы с подсчетом количества заказов каждого клиента, 
  затем выбираются топ-10 клиентов по количеству заказов. Итоговые данные объединяются 
  с помощью оператора UNION.

- Используемые функции и конструкции:

WITH — создание временных (CTE) таблиц

JOIN — соединение таблиц заказов и клиентов по customer_id

COUNT() — подсчет количества заказов клиента

GROUP BY — группировка по клиенту

ORDER BY — сортировка по количеству заказов

LIMIT — ограничение топ-10 клиентов

UNION ALL — объединение результатов двух запросов

Преобразование report_date в тип timestamp внутри запроса (если потребуется)

- Код с комментариями:

sql
-- SQL код для определения топ-10 самых частых клиентов аптек "Горздрав" и "Здравсити"

WITH gorzdrav_top_clients AS (
    SELECT
        c.customer_id,
        CONCAT_WS(' ', c.last_name, c.first_name, c.second_name) AS full_name,  -- объединение ФИО
        COUNT(po.order_id) AS orders_count                                      -- количество заказов
    FROM
        pharma_orders po
    JOIN
        customers c ON po.customer_id = c.customer_id
    WHERE
        po.pharmacy_name = 'Горздрав'                                          -- фильтр по аптеке "Горздрав"
    GROUP BY
        c.customer_id, c.last_name, c.first_name, c.second_name
    ORDER BY
        orders_count DESC                                                      -- сортировка по убыванию количества заказов
    LIMIT 10                                                                  -- топ-10 клиентов
),

zdravcity_top_clients AS (
    SELECT
        c.customer_id,
        CONCAT_WS(' ', c.last_name, c.first_name, c.second_name) AS full_name,  -- объединение ФИО
        COUNT(po.order_id) AS orders_count                                      -- количество заказов
    FROM
        pharma_orders po
    JOIN
        customers c ON po.customer_id = c.customer_id
    WHERE
        po.pharmacy_name = 'Здравсити'                                        -- фильтр по аптеке "Здравсити"
    GROUP BY
        c.customer_id, c.last_name, c.first_name, c.second_name
    ORDER BY
        orders_count DESC                                                      -- сортировка по убыванию количества заказов
    LIMIT 10                                                                  -- топ-10 клиентов
)

-- Объединяем результаты двух аптек
SELECT
    'Горздрав' AS pharmacy_name,
    customer_id,
    full_name,
    orders_count
FROM
    gorzdrav_top_clients

UNION ALL

SELECT
    'Здравсити' AS pharmacy_name,
    customer_id,
    full_name,
    orders_count
FROM
    zdravcity_top_clients;
	
	
- Итоговое решение задачи с бизнесовым ответом:
  Данный запрос позволяет выявить самых активных клиентов для аптек "Горздрав" и "Здравсити".
  Это помогает сфокусировать маркетинговые и клиентские программы на наиболее лояльных покупателях
  каждой аптеки, улучшая удержание клиентов и повышая продажи.